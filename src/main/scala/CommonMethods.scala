//ОБОБЩЕННЫЕ МЕТОДЫ

object CommonMethods extends App {
  // берем функцию от Int, возвращающую Int и возвращаем Int
//  val calc42: (Int => Int) => Int = f => f(v1 = 42)


  def calc42M[A]: (Int => A) => A = f => f(v1 = 42000000) // A - обобщаем тип,
  // чтобы можно было работать не только с интом
  println(calc42M(i =>s" number is $i"))

  // A - тип, который обрабатываем на каждом шаге,
  // B - тип, который будем накапливать
  def tailRec[A,B](iter: A => A, // iter - превращает А в следующий А
                  comb: (B, A) => B, // comb будет комбинировать B и A и генерировать новое значение аккумулятора
                  cond: A => Boolean) (start: A, init: B) :B = {  // cond - берет A, проверяет, не стоит ли нам остановиться и
        def go(x: A, acc: B): B = // когда стоит остановиться возвращаем последнее значение аккумулятора
          if (cond(x)) go(iter(x), comb(acc, x)) else acc
        go(start, init)
  }

  println(calc42M(n => // берем на вход число n
    tailRec[Int, Long](_ -1, _ + _, _ >= 0)(n, init=0 ))) // пройдемся по числу хвосторекурсивно, Int - очередной элемент для итерации, Long - тип аккумулятора
// _ -1 это мы из текущего значения на каждом шаге будем вычитать единицу
// на каждом комбинирующем шаге мы будем брать текущее значение комбинатора _ и добавлять в него значение нашего итерирующего элемента _ + _
// _ < 0 это проверка, не стало ли наше число меньше нуля
//  n - стартовое значение для нашего A, init=0 стартовое значение для аккумулятора



}
